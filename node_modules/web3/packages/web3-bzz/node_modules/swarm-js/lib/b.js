var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/******/(function (modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/var installedModules = {};
  /******/
  /******/ // The require function
  /******/function __webpack_require__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/if (installedModules[moduleId]) {
      /******/return installedModules[moduleId].exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/var module = installedModules[moduleId] = {
      /******/i: moduleId,
      /******/l: false,
      /******/exports: {}
      /******/ };
    /******/
    /******/ // Execute the module function
    /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ // Flag the module as loaded
    /******/module.l = true;
    /******/
    /******/ // Return the exports of the module
    /******/return module.exports;
    /******/
  }
  /******/
  /******/
  /******/ // expose the modules object (__webpack_modules__)
  /******/__webpack_require__.m = modules;
  /******/
  /******/ // expose the module cache
  /******/__webpack_require__.c = installedModules;
  /******/
  /******/ // define getter function for harmony exports
  /******/__webpack_require__.d = function (exports, name, getter) {
    /******/if (!__webpack_require__.o(exports, name)) {
      /******/Object.defineProperty(exports, name, {
        /******/configurable: false,
        /******/enumerable: true,
        /******/get: getter
        /******/ });
      /******/
    }
    /******/
  };
  /******/
  /******/ // getDefaultExport function for compatibility with non-harmony modules
  /******/__webpack_require__.n = function (module) {
    /******/var getter = module && module.__esModule ?
    /******/function getDefault() {
      return module['default'];
    } :
    /******/function getModuleExports() {
      return module;
    };
    /******/__webpack_require__.d(getter, 'a', getter);
    /******/return getter;
    /******/
  };
  /******/
  /******/ // Object.prototype.hasOwnProperty.call
  /******/__webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/
  /******/ // __webpack_public_path__
  /******/__webpack_require__.p = "";
  /******/
  /******/ // Load entry module and return exports
  /******/return __webpack_require__(__webpack_require__.s = 3);
  /******/
})(
/************************************************************************/
/******/[
/* 0 */
/***/function (module, exports, __webpack_require__) {

  "use strict";
  /* WEBPACK VAR INJECTION */
  (function (global) {
    /*!
    * The buffer module from node.js, for the browser.
    *
    * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
    * @license  MIT
    */
    /* eslint-disable no-proto */

    var base64 = __webpack_require__(11);
    var ieee754 = __webpack_require__(12);
    var isArray = __webpack_require__(13);

    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.
    
     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

    /*
     * Export kMaxLength after typed array support is determined.
     */
    exports.kMaxLength = kMaxLength();

    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
            return 42;
          } };
        return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
      } catch (e) {
        return false;
      }
    }

    function kMaxLength() {
      return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
    }

    function createBuffer(that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length');
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length);
        }
        that.length = length;
      }

      return that;
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer(arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length);
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error('If encoding is specified then the first argument must be a string');
        }
        return allocUnsafe(this, arg);
      }
      return from(this, arg, encodingOrOffset, length);
    }

    Buffer.poolSize = 8192; // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype;
      return arr;
    };

    function from(that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number');
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length);
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset);
      }

      return fromObject(that, value);
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
      if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        Object.defineProperty(Buffer, Symbol.species, {
          value: null,
          configurable: true
        });
      }
    }

    function assertSize(size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number');
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
    }

    function alloc(that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size);
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
      }
      return createBuffer(that, size);
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding);
    };

    function allocUnsafe(that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that;
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size);
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size);
    };

    function fromString(that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);

      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that;
    }

    function fromArrayLike(that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that;
    }

    function fromArrayBuffer(that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds');
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds');
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }
      return that;
    }

    function fromObject(that, obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that;
        }

        obj.copy(that, 0, 0, len);
        return that;
      }

      if (obj) {
        if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0);
          }
          return fromArrayLike(that, obj);
        }

        if (obj.type === 'Buffer' && isArray(obj.data)) {
          return fromArrayLike(that, obj.data);
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
    }

    function checked(length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
      }
      return length | 0;
    }

    function SlowBuffer(length) {
      if (+length != length) {
        // eslint-disable-line eqeqeq
        length = 0;
      }
      return Buffer.alloc(+length);
    }

    Buffer.isBuffer = function isBuffer(b) {
      return !!(b != null && b._isBuffer);
    };

    Buffer.compare = function compare(a, b) {
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('Arguments must be Buffers');
      }

      if (a === b) return 0;

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true;
        default:
          return false;
      }
    };

    Buffer.concat = function concat(list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      if (list.length === 0) {
        return Buffer.alloc(0);
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };

    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0;

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len;
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length;
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2;
          case 'hex':
            return len >>> 1;
          case 'base64':
            return base64ToBytes(string).length;
          default:
            if (loweredCase) return utf8ToBytes(string).length; // assume utf8
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString(encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return '';
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return '';
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return '';
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end);

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end);

          case 'ascii':
            return asciiSlice(this, start, end);

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end);

          case 'base64':
            return base64Slice(this, start, end);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true;

    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };

    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };

    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };

    Buffer.prototype.toString = function toString() {
      var length = this.length | 0;
      if (length === 0) return '';
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };

    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
      if (this === b) return true;
      return Buffer.compare(this, b) === 0;
    };

    Buffer.prototype.inspect = function inspect() {
      var str = '';
      var max = exports.INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>';
    };

    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (!Buffer.isBuffer(target)) {
        throw new TypeError('Argument must be a Buffer');
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0;

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1;

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset; // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : buffer.length - 1;
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;else return -1;
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }

      throw new TypeError('val must be string, number or Buffer');
    }

    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read(buf, i) {
        if (indexSize === 1) {
          return buf[i];
        } else {
          return buf.readUInt16BE(i * indexSize);
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }

      return -1;
    }

    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };

    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };

    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      // must be an even number of digits
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }

    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }

    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }

    function latin1Write(buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length);
    }

    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }

    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }

    Buffer.prototype.write = function write(string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
        // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
        // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
        // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length);

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length);

          case 'ascii':
            return asciiWrite(this, string, offset, length);

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length);

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };

    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }

    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res);
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }

    function asciiSlice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret;
    }

    function latin1Slice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }

    function hexSlice(buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out;
    }

    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }

    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf;
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
    }

    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val;
    };

    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val;
    };

    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };

    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val;
    };

    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val;
    };

    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return this[offset];
      return (0xff - this[offset] + 1) * -1;
    };

    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };

    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };

    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };

    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };

    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = value & 0xff;
      return offset + 1;
    };

    function objectWriteUInt16(buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 0xff;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };

    function objectWriteUInt32(buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 0xff;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 0xff;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };

    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 0xff;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 0xff;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };

    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
      if (offset < 0) throw new RangeError('Index out of range');
    }

    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };

    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
      if (end < 0) throw new RangeError('sourceEnd out of bounds');

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }

      return len;
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string');
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
      }

      if (end <= start) {
        return this;
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this;
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean(str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return '';
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str;
    }

    function stringtrim(str) {
      if (str.trim) return str.trim();
      return str.replace(/^\s+|\s+$/g, '');
    }

    function toHex(n) {
      if (n < 16) return '0' + n.toString(16);
      return n.toString(16);
    }

    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            }

            // valid lead
            leadSurrogate = codePoint;

            continue;
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
          throw new Error('Invalid code point');
        }
      }

      return bytes;
    }

    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray;
    }

    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray;
    }

    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }

    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }

    function isnan(val) {
      return val !== val; // eslint-disable-line no-self-compare
    }

    /* WEBPACK VAR INJECTION */
  }).call(exports, __webpack_require__(1));

  /***/
},
/* 1 */
/***/function (module, exports) {

  var g;

  // This works in non-strict mode
  g = function () {
    return this;
  }();

  try {
    // This works if eval is allowed (see CSP)
    g = g || Function("return this")() || (1, eval)("this");
  } catch (e) {
    // This works if the window reference is available
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === "object") g = window;
  }

  // g can still be undefined, but nothing to do about it...
  // We return undefined, instead of nothing here, so it's
  // easier to handle this case. if(!global) { ...}

  module.exports = g;

  /***/
},
/* 2 */
/***/function (module, exports) {

  module.exports = isFunction;

  var toString = Object.prototype.toString;

  function isFunction(fn) {
    var string = toString.call(fn);
    return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && (
    // IE8 and below
    fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
  };

  /***/
},
/* 3 */
/***/function (module, exports, __webpack_require__) {

  swarm = __webpack_require__(4);
  console.log(swarm);

  /***/
},
/* 4 */
/***/function (module, exports, __webpack_require__) {

  var unavailable = function unavailable() {
    throw "This swarm.js function isn't available on the browser.";
  };

  var fsp = { readFile: unavailable };
  var files = { download: unavailable, safeDownloadArchived: unavailable, directoryTree: unavailable };
  var os = { platform: unavailable, arch: unavailable };
  var path = { join: unavailable, slice: unavailable };
  var child_process = { spawn: unavailable };
  var swarm = __webpack_require__(5);

  module.exports = swarm({ fsp: fsp, files: files, os: os, path: path, child_process: child_process });

  /***/
},
/* 5 */
/***/function (module, exports, __webpack_require__) {

  var mimetype = __webpack_require__(6);
  var pick = __webpack_require__(10);
  var request = __webpack_require__(14);
  var downloadUrl = "http://ethereum-mist.s3.amazonaws.com/swarm/";
  var defaultArchives = __webpack_require__(29);
  var Buffer = __webpack_require__(0).Buffer;

  // TODO: this is a temporary fix to hide those libraries from the browser. A
  // slightly better long-term solution would be to split this file into two,
  // separating the functions that are used on Node.js from the functions that
  // are used only on the browser.
  module.exports = function (_ref) {
    var fsp = _ref.fsp,
        files = _ref.files,
        os = _ref.os,
        path = _ref.path,
        child_process = _ref.child_process;

    // ∀ a . String -> JSON -> Map String a -o Map String a
    //   Inserts a key/val pair in an object impurely.
    var impureInsert = function impureInsert(key) {
      return function (val) {
        return function (map) {
          return map[key] = val, map;
        };
      };
    };

    // String -> JSON -> Map String JSON
    //   Merges an array of keys and an array of vals into an object.
    var toMap = function toMap(keys) {
      return function (vals) {
        var map = {};
        for (var i = 0, l = keys.length; i < l; ++i) {
          map[keys[i]] = vals[i];
        }return map;
      };
    };

    // ∀ a . Map String a -> Map String a -> Map String a
    //   Merges two maps into one.
    var merge = function merge(a) {
      return function (b) {
        var map = {};
        for (var key in a) {
          map[key] = a[key];
        }for (var _key in b) {
          map[_key] = b[_key];
        }return map;
      };
    };

    // String -> String -> String
    var rawUrl = function rawUrl(swarmUrl) {
      return function (hash) {
        return swarmUrl + "/bzzr:/" + hash;
      };
    };

    // String -> String -> Promise Buffer
    //   Gets the raw contents of a Swarm hash address.
    var downloadData = function downloadData(swarmUrl) {
      return function (hash) {
        return request(rawUrl(swarmUrl)(hash), { responseType: "arraybuffer" }).then(function (arrayBuffer) {
          return new Buffer(arrayBuffer);
        });
      };
    };

    // type Entry = {"type": String, "hash": String}
    // type File = {"type": String, "data": Buffer}

    // String -> String -> Promise (Map String Entry)
    //   Solves the manifest of a Swarm address recursively.
    //   Returns a map from full paths to entries.
    var downloadEntries = function downloadEntries(swarmUrl) {
      return function (hash) {
        var search = function search(hash) {
          return function (path) {
            return function (routes) {
              // Formats an entry to the Swarm.js type.
              var format = function format(entry) {
                return {
                  type: entry.contentType,
                  hash: entry.hash };
              };

              // To download a single entry:
              //   if type is bzz-manifest, go deeper
              //   if not, add it to the routing table
              var downloadEntry = function downloadEntry(entry) {
                if (entry.path === undefined) {
                  return Promise.resolve();
                } else {
                  return entry.contentType === "application/bzz-manifest+json" ? search(entry.hash)(path + entry.path)(routes) : Promise.resolve(impureInsert(path + entry.path)(format(entry))(routes));
                }
              };

              // Downloads the initial manifest and then each entry.
              return downloadData(swarmUrl)(hash).then(function (text) {
                return JSON.parse(text.toString()).entries;
              }).then(function (entries) {
                return Promise.all(entries.map(downloadEntry));
              }).then(function () {
                return routes;
              });
            };
          };
        };

        return search(hash)("")({});
      };
    };

    // String -> String -> Promise (Map String String)
    //   Same as `downloadEntries`, but returns only hashes (no types).
    var downloadRoutes = function downloadRoutes(swarmUrl) {
      return function (hash) {
        return downloadEntries(swarmUrl)(hash).then(function (entries) {
          return toMap(Object.keys(entries))(Object.keys(entries).map(function (route) {
            return entries[route].hash;
          }));
        });
      };
    };

    // String -> String -> Promise (Map String File)
    //   Gets the entire directory tree in a Swarm address.
    //   Returns a promise mapping paths to file contents.
    var downloadDirectory = function downloadDirectory(swarmUrl) {
      return function (hash) {
        return downloadEntries(swarmUrl)(hash).then(function (entries) {
          var paths = Object.keys(entries);
          var hashs = paths.map(function (path) {
            return entries[path].hash;
          });
          var types = paths.map(function (path) {
            return entries[path].type;
          });
          var datas = hashs.map(downloadData(swarmUrl));
          var files = function files(datas) {
            return datas.map(function (data, i) {
              return { type: types[i], data: data };
            });
          };
          return Promise.all(datas).then(function (datas) {
            return toMap(paths)(files(datas));
          });
        });
      };
    };

    // String -> String -> String -> Promise String
    //   Gets the raw contents of a Swarm hash address.
    //   Returns a promise with the downloaded file path.
    var downloadDataToDisk = function downloadDataToDisk(swarmUrl) {
      return function (hash) {
        return function (filePath) {
          return files.download(rawUrl(swarmUrl)(hash))(filePath);
        };
      };
    };

    // String -> String -> String -> Promise (Map String String)
    //   Gets the entire directory tree in a Swarm address.
    //   Returns a promise mapping paths to file contents.
    var downloadDirectoryToDisk = function downloadDirectoryToDisk(swarmUrl) {
      return function (hash) {
        return function (dirPath) {
          return downloadRoutes(swarmUrl)(hash).then(function (routingTable) {
            var downloads = [];
            for (var route in routingTable) {
              if (route.length > 0) {
                var filePath = path.join(dirPath, route);
                downloads.push(downloadDataToDisk(swarmUrl)(routingTable[route])(filePath));
              };
            };
            return Promise.all(downloads).then(function () {
              return dirPath;
            });
          });
        };
      };
    };

    // String -> Buffer -> Promise String
    //   Uploads raw data to Swarm.
    //   Returns a promise with the uploaded hash.
    var uploadData = function uploadData(swarmUrl) {
      return function (data) {
        return request(swarmUrl + "/bzzr:/", {
          body: typeof data === "string" ? new Buffer(data) : data,
          method: "POST" });
      };
    };

    // String -> String -> String -> File -> Promise String
    //   Uploads a file to the Swarm manifest at a given hash, under a specific
    //   route. Returns a promise containing the uploaded hash.
    //   FIXME: for some reasons Swarm-Gateways is sometimes returning
    //   error 404 (bad request), so we retry up to 3 times. Why?
    var uploadToManifest = function uploadToManifest(swarmUrl) {
      return function (hash) {
        return function (route) {
          return function (file) {
            var attempt = function attempt(n) {
              var slashRoute = route[0] === "/" ? route : "/" + route;
              var url = swarmUrl + "/bzz:/" + hash + slashRoute;
              var opt = {
                method: "PUT",
                headers: { "Content-Type": file.type },
                body: file.data };
              return request(url, opt).catch(function (e) {
                return n > 0 && attempt(n - 1);
              });
            };
            return attempt(3);
          };
        };
      };
    };

    // String -> {type: String, data: Buffer} -> Promise String
    var uploadFile = function uploadFile(swarmUrl) {
      return function (file) {
        return uploadDirectory(swarmUrl)({ "": file });
      };
    };

    // String -> String -> Promise String
    var uploadFileFromDisk = function uploadFileFromDisk(swarmUrl) {
      return function (filePath) {
        return fsp.readFile(filePath).then(function (data) {
          return uploadFile(swarmUrl)({ type: mimetype.lookup(filePath), data: data });
        });
      };
    };

    // String -> Map String File -> Promise String
    //   Uploads a directory to Swarm. The directory is
    //   represented as a map of routes and files.
    //   A default path is encoded by having a "" route.
    var uploadDirectory = function uploadDirectory(swarmUrl) {
      return function (directory) {
        return uploadData(swarmUrl)("{}").then(function (hash) {
          var uploadRoute = function uploadRoute(route) {
            return function (hash) {
              return uploadToManifest(swarmUrl)(hash)(route)(directory[route]);
            };
          };
          var uploadToHash = function uploadToHash(hash, route) {
            return hash.then(uploadRoute(route));
          };
          return Object.keys(directory).reduce(uploadToHash, Promise.resolve(hash));
        });
      };
    };

    // String -> Promise String
    var uploadDataFromDisk = function uploadDataFromDisk(swarmUrl) {
      return function (filePath) {
        return fsp.readFile(filePath).then(uploadData(swarmUrl));
      };
    };

    // String -> Nullable String -> String -> Promise String
    var uploadDirectoryFromDisk = function uploadDirectoryFromDisk(swarmUrl) {
      return function (defaultPath) {
        return function (dirPath) {
          return files.directoryTree(dirPath).then(function (fullPaths) {
            return Promise.all(fullPaths.map(function (path) {
              return fsp.readFile(path);
            })).then(function (datas) {
              var paths = fullPaths.map(function (path) {
                return path.slice(dirPath.length);
              });
              var types = fullPaths.map(function (path) {
                return mimetype.lookup(path) || "text/plain";
              });
              return toMap(paths)(datas.map(function (data, i) {
                return { type: types[i], data: data };
              }));
            });
          }).then(function (directory) {
            return merge(defaultPath ? { "": directory[defaultPath] } : {})(directory);
          }).then(uploadDirectory(swarmUrl));
        };
      };
    };

    // String -> UploadInfo -> Promise String
    //   Simplified multi-type upload which calls the correct
    //   one based on the type of the argument given.
    var _upload = function _upload(swarmUrl) {
      return function (arg) {
        // Upload raw data from browser
        if (arg.pick === "data") {
          return pick.data().then(uploadData(swarmUrl));

          // Upload a file from browser
        } else if (arg.pick === "file") {
          return pick.file().then(uploadFile(swarmUrl));

          // Upload a directory from browser
        } else if (arg.pick === "directory") {
          return pick.directory().then(uploadDirectory(swarmUrl));

          // Upload directory/file from disk
        } else if (arg.path) {
          switch (arg.kind) {
            case "data":
              return uploadDataFromDisk(swarmUrl)(arg.path);
            case "file":
              return uploadFileFromDisk(swarmUrl)(arg.path);
            case "directory":
              return uploadDirectoryFromDisk(swarmUrl)(arg.defaultFile)(arg.path);
          };

          // Upload UTF-8 string
        } else if (typeof arg === "string") {
          return uploadData(swarmUrl)(new Buffer(arg));

          // Upload raw data (buffer)
        } else if (arg.length) {
          return uploadData(swarmUrl)(arg);

          // Upload directory with JSON
        } else if (arg instanceof Object) {
          return uploadDirectory(swarmUrl)(arg);
        }

        return Promise.reject(new Error("Bad arguments"));
      };
    };

    // String -> String -> Nullable String -> Promise (String | Buffer | Map String Buffer)
    //   Simplified multi-type download which calls the correct function based on
    //   the type of the argument given, and on whether the Swwarm address has a
    //   directory or a file.
    var _download = function _download(swarmUrl) {
      return function (hash) {
        return function (path) {
          return isDirectory(swarmUrl)(hash).then(function (isDir) {
            if (isDir) {
              return path ? downloadDirectoryToDisk(swarmUrl)(hash)(path) : downloadDirectory(swarmUrl)(hash);
            } else {
              return path ? downloadDataToDisk(swarmUrl)(hash)(path) : downloadData(swarmUrl)(hash);
            }
          });
        };
      };
    };

    // String -> Promise String
    //   Downloads the Swarm binaries into a path. Returns a promise that only
    //   resolves when the exact Swarm file is there, and verified to be correct.
    //   If it was already there to begin with, skips the download.
    var downloadBinary = function downloadBinary(path, archives) {
      var system = os.platform().replace("win32", "windows") + "-" + (os.arch() === "x64" ? "amd64" : "386");
      var archive = (archives || defaultArchives)[system];
      var archiveUrl = downloadUrl + archive.archive + ".tar.gz";
      var archiveMD5 = archive.archiveMD5;
      var binaryMD5 = archive.binaryMD5;
      return files.safeDownloadArchived(archiveUrl)(archiveMD5)(binaryMD5)(path);
    };

    // type SwarmSetup = {
    //   account : String,
    //   password : String,
    //   dataDir : String,
    //   binPath : String,
    //   ensApi : String,
    //   onDownloadProgress : Number ~> (),
    //   archives : [{
    //     archive: String,
    //     binaryMD5: String,
    //     archiveMD5: String
    //   }]
    // }

    // SwarmSetup ~> Promise Process
    //   Starts the Swarm process.
    var startProcess = function startProcess(swarmSetup) {
      return new Promise(function (resolve, reject) {
        var spawn = child_process.spawn;

        var hasString = function hasString(str) {
          return function (buffer) {
            return ('' + buffer).indexOf(str) !== -1;
          };
        };
        var account = swarmSetup.account,
            password = swarmSetup.password,
            dataDir = swarmSetup.dataDir,
            ensApi = swarmSetup.ensApi,
            privateKey = swarmSetup.privateKey;

        var STARTUP_TIMEOUT_SECS = 3;
        var WAITING_PASSWORD = 0;
        var STARTING = 1;
        var LISTENING = 2;
        var PASSWORD_PROMPT_HOOK = "Passphrase";
        var LISTENING_HOOK = "Swarm http proxy started";

        var state = WAITING_PASSWORD;

        var swarmProcess = spawn(swarmSetup.binPath, ['--bzzaccount', account || privateKey, '--datadir', dataDir, '--ens-api', ensApi]);

        var handleProcessOutput = function handleProcessOutput(data) {
          if (state === WAITING_PASSWORD && hasString(PASSWORD_PROMPT_HOOK)(data)) {
            setTimeout(function () {
              state = STARTING;
              swarmProcess.stdin.write(password + '\n');
            }, 500);
          } else if (hasString(LISTENING_HOOK)(data)) {
            state = LISTENING;
            clearTimeout(timeout);
            resolve(swarmProcess);
          }
        };

        swarmProcess.stdout.on('data', handleProcessOutput);
        swarmProcess.stderr.on('data', handleProcessOutput);
        //swarmProcess.on('close', () => setTimeout(restart, 2000));

        var restart = function restart() {
          return startProcess(swarmSetup).then(resolve).catch(reject);
        };
        var error = function error() {
          return reject(new Error("Couldn't start swarm process."));
        };
        var timeout = setTimeout(error, 20000);
      });
    };

    // Process ~> Promise ()
    //   Stops the Swarm process.
    var stopProcess = function stopProcess(process) {
      return new Promise(function (resolve, reject) {
        process.stderr.removeAllListeners('data');
        process.stdout.removeAllListeners('data');
        process.stdin.removeAllListeners('error');
        process.removeAllListeners('error');
        process.removeAllListeners('exit');
        process.kill('SIGINT');

        var killTimeout = setTimeout(function () {
          return process.kill('SIGKILL');
        }, 8000);

        process.once('close', function () {
          clearTimeout(killTimeout);
          resolve();
        });
      });
    };

    // SwarmSetup -> (SwarmAPI -> Promise ()) -> Promise ()
    //   Receives a Swarm configuration object and a callback function. It then
    //   checks if a local Swarm node is running. If no local Swarm is found, it
    //   downloads the Swarm binaries to the dataDir (if not there), checksums,
    //   starts the Swarm process and calls the callback function with an API
    //   object using the local node. That callback must return a promise which
    //   will resolve when it is done using the API, so that this function can
    //   close the Swarm process properly. Returns a promise that resolves when the
    //   user is done with the API and the Swarm process is closed.
    //   TODO: check if Swarm process is already running (improve `isAvailable`)
    var local = function local(swarmSetup) {
      return function (useAPI) {
        return _isAvailable("http://localhost:8500").then(function (isAvailable) {
          return isAvailable ? useAPI(at("http://localhost:8500")).then(function () {}) : downloadBinary(swarmSetup.binPath, swarmSetup.archives).onData(function (data) {
            return (swarmSetup.onProgress || function () {})(data.length);
          }).then(function () {
            return startProcess(swarmSetup);
          }).then(function (process) {
            return useAPI(at("http://localhost:8500")).then(function () {
              return process;
            });
          }).then(stopProcess);
        });
      };
    };

    // String ~> Promise Bool
    //   Returns true if Swarm is available on `url`.
    //   Perfoms a test upload to determine that.
    //   TODO: improve this?
    var _isAvailable = function _isAvailable(swarmUrl) {
      var testFile = "test";
      var testHash = "c9a99c7d326dcc6316f32fe2625b311f6dc49a175e6877681ded93137d3569e7";
      return uploadData(swarmUrl)(testFile).then(function (hash) {
        return hash === testHash;
      }).catch(function () {
        return false;
      });
    };

    // String -> String ~> Promise Bool
    //   Returns a Promise which is true if that Swarm address is a directory.
    //   Determines that by checking that it (i) is a JSON, (ii) has a .entries.
    //   TODO: improve this?
    var isDirectory = function isDirectory(swarmUrl) {
      return function (hash) {
        return downloadData(swarmUrl)(hash).then(function (data) {
          return !!JSON.parse(data.toString()).entries;
        }).catch(function () {
          return false;
        });
      };
    };

    // Uncurries a function; used to allow the f(x,y,z) style on exports.
    var uncurry = function uncurry(f) {
      return function (a, b, c, d, e) {
        // Hardcoded because efficiency (`arguments` is very slow).
        if (typeof a !== "undefined") f = f(a);
        if (typeof b !== "undefined") f = f(b);
        if (typeof c !== "undefined") f = f(c);
        if (typeof d !== "undefined") f = f(d);
        if (typeof e !== "undefined") f = f(e);
        return f;
      };
    };

    // () -> Promise Bool
    //   Not sure how to mock Swarm to test it properly. Ideas?
    var test = function test() {
      return Promise.resolve(true);
    };

    // String -> SwarmAPI
    //   Fixes the `swarmUrl`, returning an API where you don't have to pass it.
    var at = function at(swarmUrl) {
      return {
        download: function download(hash, path) {
          return _download(swarmUrl)(hash)(path);
        },
        downloadData: uncurry(downloadData(swarmUrl)),
        downloadDataToDisk: uncurry(downloadDataToDisk(swarmUrl)),
        downloadDirectory: uncurry(downloadDirectory(swarmUrl)),
        downloadDirectoryToDisk: uncurry(downloadDirectoryToDisk(swarmUrl)),
        downloadEntries: uncurry(downloadEntries(swarmUrl)),
        downloadRoutes: uncurry(downloadRoutes(swarmUrl)),
        isAvailable: function isAvailable() {
          return _isAvailable(swarmUrl);
        },
        upload: function upload(arg) {
          return _upload(swarmUrl)(arg);
        },
        uploadData: uncurry(uploadData(swarmUrl)),
        uploadFile: uncurry(uploadFile(swarmUrl)),
        uploadFileFromDisk: uncurry(uploadFile(swarmUrl)),
        uploadDataFromDisk: uncurry(uploadDataFromDisk(swarmUrl)),
        uploadDirectory: uncurry(uploadDirectory(swarmUrl)),
        uploadDirectoryFromDisk: uncurry(uploadDirectoryFromDisk(swarmUrl)),
        uploadToManifest: uncurry(uploadToManifest(swarmUrl)),
        pick: pick
      };
    };

    return {
      at: at,
      local: local,
      download: _download,
      downloadBinary: downloadBinary,
      downloadData: downloadData,
      downloadDataToDisk: downloadDataToDisk,
      downloadDirectory: downloadDirectory,
      downloadDirectoryToDisk: downloadDirectoryToDisk,
      downloadEntries: downloadEntries,
      downloadRoutes: downloadRoutes,
      isAvailable: _isAvailable,
      startProcess: startProcess,
      stopProcess: stopProcess,
      upload: _upload,
      uploadData: uploadData,
      uploadDataFromDisk: uploadDataFromDisk,
      uploadFile: uploadFile,
      uploadFileFromDisk: uploadFileFromDisk,
      uploadDirectory: uploadDirectory,
      uploadDirectoryFromDisk: uploadDirectoryFromDisk,
      uploadToManifest: uploadToManifest,
      pick: pick
    };
  };

  /***/
},
/* 6 */
/***/function (module, exports, __webpack_require__) {

  //
  // mimetype.js - A catalog object of mime types based on file extensions
  //
  // @author: R. S. Doiel, <rsdoiel@gmail.com>
  // copyright (c) 2012 all rights reserved
  //
  // Released under New the BSD License.
  // See: http://opensource.org/licenses/bsd-license.php
  //
  /*jslint indent: 4 */
  /*global require, exports */
  (function (self) {
    "use strict";

    var path, MimeType;

    // If we're NodeJS I can use the path module.
    // If I'm MongoDB shell, not available.
    if (!function webpackMissingModule() {
      var e = new Error("Cannot find module \".\"");e.code = 'MODULE_NOT_FOUND';throw e;
    }() !== undefined) {
      path = __webpack_require__(8);
    } else {
      path = {
        extname: function extname(filename) {
          if (filename.lastIndexOf(".") > 0) {
            return filename.substr(filename.lastIndexOf("."));
          }
        }
      };
    }

    if (exports === undefined) {
      exports = {};
    }

    MimeType = {
      charset: 'UTF-8',
      catalog: {},
      lookup: function lookup(fname, include_charset, default_mime_type) {
        var ext,
            charset = this.charset;

        if (include_charset === undefined) {
          include_charset = false;
        }

        if (typeof include_charset === "string") {
          charset = include_charset;
          include_charset = true;
        }

        if (path.extname !== undefined) {
          ext = path.extname(fname).toLowerCase();
        } else if (fname.lastIndexOf('.') > 0) {
          ext = fname.substr(fname.lastIndexOf('.')).toLowerCase();
        } else {
          ext = fname;
        }

        // Handle the special cases where their is no extension
        // e..g README, manifest, LICENSE, TODO
        if (ext === "") {
          ext = fname;
        }

        if (this.catalog[ext] !== undefined) {
          if (include_charset === true && this.catalog[ext].indexOf('text/') === 0 && this.catalog[ext].indexOf('charset') < 0) {
            return this.catalog[ext] + '; charset=' + charset;
          } else {
            return this.catalog[ext];
          }
        } else if (default_mime_type !== undefined) {
          if (include_charset === true && default_mime_type.indexOf('text/') === 0) {
            return default_mime_type + '; charset=' + charset;
          }
          return default_mime_type;
        }
        return false;
      },
      set: function set(exts, mime_type_string) {
        var result = true,
            self = this;
        //console.log("DEBUG exts.indexOf(',')", typeof exts.indexOf(','), exts.indexOf(','));
        if (exts.indexOf(',') > -1) {
          exts.split(',').forEach(function (ext) {
            ext = ext.trim();
            self.catalog[ext] = mime_type_string;
            if (self.catalog[ext] !== mime_type_string) {
              result = false;
            }
          });
        } else {
          self.catalog[exts] = mime_type_string;
        }
        return result;
      },
      del: function del(ext) {
        delete this.catalog[ext];
        return this.catalog[ext] === undefined;
      },
      forEach: function forEach(callback) {
        var self = this,
            ext;
        // Mongo 2.2. Shell doesn't support Object.keys()
        for (ext in self.catalog) {
          if (self.catalog.hasOwnProperty(ext)) {
            callback(ext, self.catalog[ext]);
          }
        }
        return self.catalog;
      }
    };

    // From Apache project's mime type list.
    MimeType.set(".ez", "application/andrew-inset");
    MimeType.set(".aw", "application/applixware");
    MimeType.set(".atom", "application/atom+xml");
    MimeType.set(".atomcat", "application/atomcat+xml");
    MimeType.set(".atomsvc", "application/atomsvc+xml");
    MimeType.set(".ccxml", "application/ccxml+xml");
    MimeType.set(".cu", "application/cu-seeme");
    MimeType.set(".davmount", "application/davmount+xml");
    MimeType.set(".ecma", "application/ecmascript");
    MimeType.set(".emma", "application/emma+xml");
    MimeType.set(".epub", "application/epub+zip");
    MimeType.set(".pfr", "application/font-tdpfr");
    MimeType.set(".stk", "application/hyperstudio");
    MimeType.set(".jar", "application/java-archive");
    MimeType.set(".ser", "application/java-serialized-object");
    MimeType.set(".class", "application/java-vm");
    MimeType.set(".js", "application/javascript");
    MimeType.set(".json", "application/json");
    MimeType.set(".lostxml", "application/lost+xml");
    MimeType.set(".hqx", "application/mac-binhex40");
    MimeType.set(".cpt", "application/mac-compactpro");
    MimeType.set(".mrc", "application/marc");
    MimeType.set(".ma,.nb,.mb", "application/mathematica");
    MimeType.set(".mathml", "application/mathml+xml");
    MimeType.set(".mbox", "application/mbox");
    MimeType.set(".mscml", "application/mediaservercontrol+xml");
    MimeType.set(".mp4s", "application/mp4");
    MimeType.set(".doc,.dot", "application/msword");
    MimeType.set(".mxf", "application/mxf");
    MimeType.set(".oda", "application/oda");
    MimeType.set(".opf", "application/oebps-package+xml");
    MimeType.set(".ogx", "application/ogg");
    MimeType.set(".onetoc,.onetoc2,.onetmp,.onepkg", "application/onenote");
    MimeType.set(".xer", "application/patch-ops-error+xml");
    MimeType.set(".pdf", "application/pdf");
    MimeType.set(".pgp", "application/pgp-encrypted");
    MimeType.set(".asc,.sig", "application/pgp-signature");
    MimeType.set(".prf", "application/pics-rules");
    MimeType.set(".p10", "application/pkcs10");
    MimeType.set(".p7m,.p7c", "application/pkcs7-mime");
    MimeType.set(".p7s", "application/pkcs7-signature");
    MimeType.set(".cer", "application/pkix-cert");
    MimeType.set(".crl", "application/pkix-crl");
    MimeType.set(".pkipath", "application/pkix-pkipath");
    MimeType.set(".pki", "application/pkixcmp");
    MimeType.set(".pls", "application/pls+xml");
    MimeType.set(".ai,.eps,.ps", "application/postscript");
    MimeType.set(".cww", "application/prs.cww");
    MimeType.set(".rdf", "application/rdf+xml");
    MimeType.set(".rif", "application/reginfo+xml");
    MimeType.set(".rnc", "application/relax-ng-compact-syntax");
    MimeType.set(".rl", "application/resource-lists+xml");
    MimeType.set(".rld", "application/resource-lists-diff+xml");
    MimeType.set(".rs", "application/rls-services+xml");
    MimeType.set(".rsd", "application/rsd+xml");
    MimeType.set(".rss", "application/rss+xml");
    MimeType.set(".rtf", "application/rtf");
    MimeType.set(".sbml", "application/sbml+xml");
    MimeType.set(".scq", "application/scvp-cv-request");
    MimeType.set(".scs", "application/scvp-cv-response");
    MimeType.set(".spq", "application/scvp-vp-request");
    MimeType.set(".spp", "application/scvp-vp-response");
    MimeType.set(".sdp", "application/sdp");
    MimeType.set(".setpay", "application/set-payment-initiation");
    MimeType.set(".setreg", "application/set-registration-initiation");
    MimeType.set(".shf", "application/shf+xml");
    MimeType.set(".smi,.smil", "application/smil+xml");
    MimeType.set(".rq", "application/sparql-query");
    MimeType.set(".srx", "application/sparql-results+xml");
    MimeType.set(".gram", "application/srgs");
    MimeType.set(".grxml", "application/srgs+xml");
    MimeType.set(".ssml", "application/ssml+xml");
    MimeType.set(".plb", "application/vnd.3gpp.pic-bw-large");
    MimeType.set(".psb", "application/vnd.3gpp.pic-bw-small");
    MimeType.set(".pvb", "application/vnd.3gpp.pic-bw-var");
    MimeType.set(".tcap", "application/vnd.3gpp2.tcap");
    MimeType.set(".pwn", "application/vnd.3m.post-it-notes");
    MimeType.set(".aso", "application/vnd.accpac.simply.aso");
    MimeType.set(".imp", "application/vnd.accpac.simply.imp");
    MimeType.set(".acu", "application/vnd.acucobol");
    MimeType.set(".atc,.acutc", "application/vnd.acucorp");
    MimeType.set(".air", "application/vnd.adobe.air-application-installer-package+zip");
    MimeType.set(".xdp", "application/vnd.adobe.xdp+xml");
    MimeType.set(".xfdf", "application/vnd.adobe.xfdf");
    MimeType.set(".azf", "application/vnd.airzip.filesecure.azf");
    MimeType.set(".azs", "application/vnd.airzip.filesecure.azs");
    MimeType.set(".azw", "application/vnd.amazon.ebook");
    MimeType.set(".acc", "application/vnd.americandynamics.acc");
    MimeType.set(".ami", "application/vnd.amiga.ami");
    MimeType.set(".apk", "application/vnd.android.package-archive");
    MimeType.set(".cii", "application/vnd.anser-web-certificate-issue-initiation");
    MimeType.set(".fti", "application/vnd.anser-web-funds-transfer-initiation");
    MimeType.set(".atx", "application/vnd.antix.game-component");
    MimeType.set(".mpkg", "application/vnd.apple.installer+xml");
    MimeType.set(".swi", "application/vnd.arastra.swi");
    MimeType.set(".aep", "application/vnd.audiograph");
    MimeType.set(".mpm", "application/vnd.blueice.multipass");
    MimeType.set(".bmi", "application/vnd.bmi");
    MimeType.set(".rep", "application/vnd.businessobjects");
    MimeType.set(".cdxml", "application/vnd.chemdraw+xml");
    MimeType.set(".mmd", "application/vnd.chipnuts.karaoke-mmd");
    MimeType.set(".cdy", "application/vnd.cinderella");
    MimeType.set(".cla", "application/vnd.claymore");
    MimeType.set(".c4g,.c4d,.c4f,.c4p,.c4u", "application/vnd.clonk.c4group");
    MimeType.set(".csp", "application/vnd.commonspace");
    MimeType.set(".cdbcmsg", "application/vnd.contact.cmsg");
    MimeType.set(".cmc", "application/vnd.cosmocaller");
    MimeType.set(".clkx", "application/vnd.crick.clicker");
    MimeType.set(".clkk", "application/vnd.crick.clicker.keyboard");
    MimeType.set(".clkp", "application/vnd.crick.clicker.palette");
    MimeType.set(".clkt", "application/vnd.crick.clicker.template");
    MimeType.set(".clkw", "application/vnd.crick.clicker.wordbank");
    MimeType.set(".wbs", "application/vnd.criticaltools.wbs+xml");
    MimeType.set(".pml", "application/vnd.ctc-posml");
    MimeType.set(".ppd", "application/vnd.cups-ppd");
    MimeType.set(".car", "application/vnd.curl.car");
    MimeType.set(".pcurl", "application/vnd.curl.pcurl");
    MimeType.set(".rdz", "application/vnd.data-vision.rdz");
    MimeType.set(".fe_launch", "application/vnd.denovo.fcselayout-link");
    MimeType.set(".dna", "application/vnd.dna");
    MimeType.set(".mlp", "application/vnd.dolby.mlp");
    MimeType.set(".dpg", "application/vnd.dpgraph");
    MimeType.set(".dfac", "application/vnd.dreamfactory");
    MimeType.set(".geo", "application/vnd.dynageo");
    MimeType.set(".mag", "application/vnd.ecowin.chart");
    MimeType.set(".nml", "application/vnd.enliven");
    MimeType.set(".esf", "application/vnd.epson.esf");
    MimeType.set(".msf", "application/vnd.epson.msf");
    MimeType.set(".qam", "application/vnd.epson.quickanime");
    MimeType.set(".slt", "application/vnd.epson.salt");
    MimeType.set(".ssf", "application/vnd.epson.ssf");
    MimeType.set(".es3,.et3", "application/vnd.eszigno3+xml");
    MimeType.set(".ez2", "application/vnd.ezpix-album");
    MimeType.set(".ez3", "application/vnd.ezpix-package");
    MimeType.set(".fdf", "application/vnd.fdf");
    MimeType.set(".mseed", "application/vnd.fdsn.mseed");
    MimeType.set(".seed,.dataless", "application/vnd.fdsn.seed");
    MimeType.set(".gph", "application/vnd.flographit");
    MimeType.set(".ftc", "application/vnd.fluxtime.clip");
    MimeType.set(".fm,.frame,.maker,.book", "application/vnd.framemaker");
    MimeType.set(".fnc", "application/vnd.frogans.fnc");
    MimeType.set(".ltf", "application/vnd.frogans.ltf");
    MimeType.set(".fsc", "application/vnd.fsc.weblaunch");
    MimeType.set(".oas", "application/vnd.fujitsu.oasys");
    MimeType.set(".oa2", "application/vnd.fujitsu.oasys2");
    MimeType.set(".oa3", "application/vnd.fujitsu.oasys3");
    MimeType.set(".fg5", "application/vnd.fujitsu.oasysgp");
    MimeType.set(".bh2", "application/vnd.fujitsu.oasysprs");
    MimeType.set(".ddd", "application/vnd.fujixerox.ddd");
    MimeType.set(".xdw", "application/vnd.fujixerox.docuworks");
    MimeType.set(".xbd", "application/vnd.fujixerox.docuworks.binder");
    MimeType.set(".fzs", "application/vnd.fuzzysheet");
    MimeType.set(".txd", "application/vnd.genomatix.tuxedo");
    MimeType.set(".ggb", "application/vnd.geogebra.file");
    MimeType.set(".ggt", "application/vnd.geogebra.tool");
    MimeType.set(".gex,.gre", "application/vnd.geometry-explorer");
    MimeType.set(".gmx", "application/vnd.gmx");
    MimeType.set(".kml", "application/vnd.google-earth.kml+xml");
    MimeType.set(".kmz", "application/vnd.google-earth.kmz");
    MimeType.set(".gqf,.gqs", "application/vnd.grafeq");
    MimeType.set(".gac", "application/vnd.groove-account");
    MimeType.set(".ghf", "application/vnd.groove-help");
    MimeType.set(".gim", "application/vnd.groove-identity-message");
    MimeType.set(".grv", "application/vnd.groove-injector");
    MimeType.set(".gtm", "application/vnd.groove-tool-message");
    MimeType.set(".tpl", "application/vnd.groove-tool-template");
    MimeType.set(".vcg", "application/vnd.groove-vcard");
    MimeType.set(".zmm", "application/vnd.handheld-entertainment+xml");
    MimeType.set(".hbci", "application/vnd.hbci");
    MimeType.set(".les", "application/vnd.hhe.lesson-player");
    MimeType.set(".hpgl", "application/vnd.hp-hpgl");
    MimeType.set(".hpid", "application/vnd.hp-hpid");
    MimeType.set(".hps", "application/vnd.hp-hps");
    MimeType.set(".jlt", "application/vnd.hp-jlyt");
    MimeType.set(".pcl", "application/vnd.hp-pcl");
    MimeType.set(".pclxl", "application/vnd.hp-pclxl");
    MimeType.set(".sfd-hdstx", "application/vnd.hydrostatix.sof-data");
    MimeType.set(".x3d", "application/vnd.hzn-3d-crossword");
    MimeType.set(".mpy", "application/vnd.ibm.minipay");
    MimeType.set(".afp,.listafp,.list3820", "application/vnd.ibm.modcap");
    MimeType.set(".irm", "application/vnd.ibm.rights-management");
    MimeType.set(".sc", "application/vnd.ibm.secure-container");
    MimeType.set(".icc,.icm", "application/vnd.iccprofile");
    MimeType.set(".igl", "application/vnd.igloader");
    MimeType.set(".ivp", "application/vnd.immervision-ivp");
    MimeType.set(".ivu", "application/vnd.immervision-ivu");
    MimeType.set(".xpw,.xpx", "application/vnd.intercon.formnet");
    MimeType.set(".qbo", "application/vnd.intu.qbo");
    MimeType.set(".qfx", "application/vnd.intu.qfx");
    MimeType.set(".rcprofile", "application/vnd.ipunplugged.rcprofile");
    MimeType.set(".irp", "application/vnd.irepository.package+xml");
    MimeType.set(".xpr", "application/vnd.is-xpr");
    MimeType.set(".jam", "application/vnd.jam");
    MimeType.set(".rms", "application/vnd.jcp.javame.midlet-rms");
    MimeType.set(".jisp", "application/vnd.jisp");
    MimeType.set(".joda", "application/vnd.joost.joda-archive");
    MimeType.set(".ktz,.ktr", "application/vnd.kahootz");
    MimeType.set(".karbon", "application/vnd.kde.karbon");
    MimeType.set(".chrt", "application/vnd.kde.kchart");
    MimeType.set(".kfo", "application/vnd.kde.kformula");
    MimeType.set(".flw", "application/vnd.kde.kivio");
    MimeType.set(".kon", "application/vnd.kde.kontour");
    MimeType.set(".kpr,.kpt", "application/vnd.kde.kpresenter");
    MimeType.set(".ksp", "application/vnd.kde.kspread");
    MimeType.set(".kwd,.kwt", "application/vnd.kde.kword");
    MimeType.set(".htke", "application/vnd.kenameaapp");
    MimeType.set(".kia", "application/vnd.kidspiration");
    MimeType.set(".kne,.knp", "application/vnd.kinar");
    MimeType.set(".skp,.skd,.skt,.skm", "application/vnd.koan");
    MimeType.set(".sse", "application/vnd.kodak-descriptor");
    MimeType.set(".lbd", "application/vnd.llamagraphics.life-balance.desktop");
    MimeType.set(".lbe", "application/vnd.llamagraphics.life-balance.exchange+xml");
    MimeType.set(".123", "application/vnd.lotus-1-2-3");
    MimeType.set(".apr", "application/vnd.lotus-approach");
    MimeType.set(".pre", "application/vnd.lotus-freelance");
    MimeType.set(".nsf", "application/vnd.lotus-notes");
    MimeType.set(".org", "application/vnd.lotus-organizer");
    MimeType.set(".scm", "application/vnd.lotus-screencam");
    MimeType.set(".lwp", "application/vnd.lotus-wordpro");
    MimeType.set(".portpkg", "application/vnd.macports.portpkg");
    MimeType.set(".mcd", "application/vnd.mcd");
    MimeType.set(".mc1", "application/vnd.medcalcdata");
    MimeType.set(".cdkey", "application/vnd.mediastation.cdkey");
    MimeType.set(".mwf", "application/vnd.mfer");
    MimeType.set(".mfm", "application/vnd.mfmp");
    MimeType.set(".flo", "application/vnd.micrografx.flo");
    MimeType.set(".igx", "application/vnd.micrografx.igx");
    MimeType.set(".mif", "application/vnd.mif");
    MimeType.set(".daf", "application/vnd.mobius.daf");
    MimeType.set(".dis", "application/vnd.mobius.dis");
    MimeType.set(".mbk", "application/vnd.mobius.mbk");
    MimeType.set(".mqy", "application/vnd.mobius.mqy");
    MimeType.set(".msl", "application/vnd.mobius.msl");
    MimeType.set(".plc", "application/vnd.mobius.plc");
    MimeType.set(".txf", "application/vnd.mobius.txf");
    MimeType.set(".mpn", "application/vnd.mophun.application");
    MimeType.set(".mpc", "application/vnd.mophun.certificate");
    MimeType.set(".xul", "application/vnd.mozilla.xul+xml");
    MimeType.set(".cil", "application/vnd.ms-artgalry");
    MimeType.set(".cab", "application/vnd.ms-cab-compressed");
    MimeType.set(".xls,.xlm,.xla,.xlc,.xlt,.xlw", "application/vnd.ms-excel");
    MimeType.set(".xlam", "application/vnd.ms-excel.addin.macroenabled.12");
    MimeType.set(".xlsb", "application/vnd.ms-excel.sheet.binary.macroenabled.12");
    MimeType.set(".xlsm", "application/vnd.ms-excel.sheet.macroenabled.12");
    MimeType.set(".xltm", "application/vnd.ms-excel.template.macroenabled.12");
    MimeType.set(".eot", "application/vnd.ms-fontobject");
    MimeType.set(".chm", "application/vnd.ms-htmlhelp");
    MimeType.set(".ims", "application/vnd.ms-ims");
    MimeType.set(".lrm", "application/vnd.ms-lrm");
    MimeType.set(".cat", "application/vnd.ms-pki.seccat");
    MimeType.set(".stl", "application/vnd.ms-pki.stl");
    MimeType.set(".ppt,.pps,.pot", "application/vnd.ms-powerpoint");
    MimeType.set(".ppam", "application/vnd.ms-powerpoint.addin.macroenabled.12");
    MimeType.set(".pptm", "application/vnd.ms-powerpoint.presentation.macroenabled.12");
    MimeType.set(".sldm", "application/vnd.ms-powerpoint.slide.macroenabled.12");
    MimeType.set(".ppsm", "application/vnd.ms-powerpoint.slideshow.macroenabled.12");
    MimeType.set(".potm", "application/vnd.ms-powerpoint.template.macroenabled.12");
    MimeType.set(".mpp,.mpt", "application/vnd.ms-project");
    MimeType.set(".docm", "application/vnd.ms-word.document.macroenabled.12");
    MimeType.set(".dotm", "application/vnd.ms-word.template.macroenabled.12");
    MimeType.set(".wps,.wks,.wcm,.wdb", "application/vnd.ms-works");
    MimeType.set(".wpl", "application/vnd.ms-wpl");
    MimeType.set(".xps", "application/vnd.ms-xpsdocument");
    MimeType.set(".mseq", "application/vnd.mseq");
    MimeType.set(".mus", "application/vnd.musician");
    MimeType.set(".msty", "application/vnd.muvee.style");
    MimeType.set(".nlu", "application/vnd.neurolanguage.nlu");
    MimeType.set(".nnd", "application/vnd.noblenet-directory");
    MimeType.set(".nns", "application/vnd.noblenet-sealer");
    MimeType.set(".nnw", "application/vnd.noblenet-web");
    MimeType.set(".ngdat", "application/vnd.nokia.n-gage.data");
    MimeType.set(".n-gage", "application/vnd.nokia.n-gage.symbian.install");
    MimeType.set(".rpst", "application/vnd.nokia.radio-preset");
    MimeType.set(".rpss", "application/vnd.nokia.radio-presets");
    MimeType.set(".edm", "application/vnd.novadigm.edm");
    MimeType.set(".edx", "application/vnd.novadigm.edx");
    MimeType.set(".ext", "application/vnd.novadigm.ext");
    MimeType.set(".odc", "application/vnd.oasis.opendocument.chart");
    MimeType.set(".otc", "application/vnd.oasis.opendocument.chart-template");
    MimeType.set(".odb", "application/vnd.oasis.opendocument.database");
    MimeType.set(".odf", "application/vnd.oasis.opendocument.formula");
    MimeType.set(".odft", "application/vnd.oasis.opendocument.formula-template");
    MimeType.set(".odg", "application/vnd.oasis.opendocument.graphics");
    MimeType.set(".otg", "application/vnd.oasis.opendocument.graphics-template");
    MimeType.set(".odi", "application/vnd.oasis.opendocument.image");
    MimeType.set(".oti", "application/vnd.oasis.opendocument.image-template");
    MimeType.set(".odp", "application/vnd.oasis.opendocument.presentation");
    MimeType.set(".ods", "application/vnd.oasis.opendocument.spreadsheet");
    MimeType.set(".ots", "application/vnd.oasis.opendocument.spreadsheet-template");
    MimeType.set(".odt", "application/vnd.oasis.opendocument.text");
    MimeType.set(".otm", "application/vnd.oasis.opendocument.text-master");
    MimeType.set(".ott", "application/vnd.oasis.opendocument.text-template");
    MimeType.set(".oth", "application/vnd.oasis.opendocument.text-web");
    MimeType.set(".xo", "application/vnd.olpc-sugar");
    MimeType.set(".dd2", "application/vnd.oma.dd2+xml");
    MimeType.set(".oxt", "application/vnd.openofficeorg.extension");
    MimeType.set(".pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation");
    MimeType.set(".sldx", "application/vnd.openxmlformats-officedocument.presentationml.slide");
    MimeType.set(".ppsx", "application/vnd.openxmlformats-officedocument.presentationml.slideshow");
    MimeType.set(".potx", "application/vnd.openxmlformats-officedocument.presentationml.template");
    MimeType.set(".xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
    MimeType.set(".xltx", "application/vnd.openxmlformats-officedocument.spreadsheetml.template");
    MimeType.set(".docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
    MimeType.set(".dotx", "application/vnd.openxmlformats-officedocument.wordprocessingml.template");
    MimeType.set(".dp", "application/vnd.osgi.dp");
    MimeType.set(".pdb,.pqa,.oprc", "application/vnd.palm");
    MimeType.set(".str", "application/vnd.pg.format");
    MimeType.set(".ei6", "application/vnd.pg.osasli");
    MimeType.set(".efif", "application/vnd.picsel");
    MimeType.set(".plf", "application/vnd.pocketlearn");
    MimeType.set(".pbd", "application/vnd.powerbuilder6");
    MimeType.set(".box", "application/vnd.previewsystems.box");
    MimeType.set(".mgz", "application/vnd.proteus.magazine");
    MimeType.set(".qps", "application/vnd.publishare-delta-tree");
    MimeType.set(".ptid", "application/vnd.pvi.ptid1");
    MimeType.set(".qxd,.qxt,.qwd,.qwt,.qxl,.qxb", "application/vnd.quark.quarkxpress");
    MimeType.set(".mxl", "application/vnd.recordare.musicxml");
    MimeType.set(".musicxml", "application/vnd.recordare.musicxml+xml");
    MimeType.set(".cod", "application/vnd.rim.cod");
    MimeType.set(".rm", "application/vnd.rn-realmedia");
    MimeType.set(".link66", "application/vnd.route66.link66+xml");
    MimeType.set(".see", "application/vnd.seemail");
    MimeType.set(".sema", "application/vnd.sema");
    MimeType.set(".semd", "application/vnd.semd");
    MimeType.set(".semf", "application/vnd.semf");
    MimeType.set(".ifm", "application/vnd.shana.informed.formdata");
    MimeType.set(".itp", "application/vnd.shana.informed.formtemplate");
    MimeType.set(".iif", "application/vnd.shana.informed.interchange");
    MimeType.set(".ipk", "application/vnd.shana.informed.package");
    MimeType.set(".twd,.twds", "application/vnd.simtech-mindmapper");
    MimeType.set(".mmf", "application/vnd.smaf");
    MimeType.set(".teacher", "application/vnd.smart.teacher");
    MimeType.set(".sdkm,.sdkd", "application/vnd.solent.sdkm+xml");
    MimeType.set(".dxp", "application/vnd.spotfire.dxp");
    MimeType.set(".sfs", "application/vnd.spotfire.sfs");
    MimeType.set(".sdc", "application/vnd.stardivision.calc");
    MimeType.set(".sda", "application/vnd.stardivision.draw");
    MimeType.set(".sdd", "application/vnd.stardivision.impress");
    MimeType.set(".smf", "application/vnd.stardivision.math");
    MimeType.set(".sdw", "application/vnd.stardivision.writer");
    MimeType.set(".vor", "application/vnd.stardivision.writer");
    MimeType.set(".sgl", "application/vnd.stardivision.writer-global");
    MimeType.set(".sxc", "application/vnd.sun.xml.calc");
    MimeType.set(".stc", "application/vnd.sun.xml.calc.template");
    MimeType.set(".sxd", "application/vnd.sun.xml.draw");
    MimeType.set(".std", "application/vnd.sun.xml.draw.template");
    MimeType.set(".sxi", "application/vnd.sun.xml.impress");
    MimeType.set(".sti", "application/vnd.sun.xml.impress.template");
    MimeType.set(".sxm", "application/vnd.sun.xml.math");
    MimeType.set(".sxw", "application/vnd.sun.xml.writer");
    MimeType.set(".sxg", "application/vnd.sun.xml.writer.global");
    MimeType.set(".stw", "application/vnd.sun.xml.writer.template");
    MimeType.set(".sus,.susp", "application/vnd.sus-calendar");
    MimeType.set(".svd", "application/vnd.svd");
    MimeType.set(".sis,.sisx", "application/vnd.symbian.install");
    MimeType.set(".xsm", "application/vnd.syncml+xml");
    MimeType.set(".bdm", "application/vnd.syncml.dm+wbxml");
    MimeType.set(".xdm", "application/vnd.syncml.dm+xml");
    MimeType.set(".tao", "application/vnd.tao.intent-module-archive");
    MimeType.set(".tmo", "application/vnd.tmobile-livetv");
    MimeType.set(".tpt", "application/vnd.trid.tpt");
    MimeType.set(".mxs", "application/vnd.triscape.mxs");
    MimeType.set(".tra", "application/vnd.trueapp");
    MimeType.set(".ufd,.ufdl", "application/vnd.ufdl");
    MimeType.set(".utz", "application/vnd.uiq.theme");
    MimeType.set(".umj", "application/vnd.umajin");
    MimeType.set(".unityweb", "application/vnd.unity");
    MimeType.set(".uoml", "application/vnd.uoml+xml");
    MimeType.set(".vcx", "application/vnd.vcx");
    MimeType.set(".vsd,.vst,.vss,.vsw", "application/vnd.visio");
    MimeType.set(".vis", "application/vnd.visionary");
    MimeType.set(".vsf", "application/vnd.vsf");
    MimeType.set(".wbxml", "application/vnd.wap.wbxml");
    MimeType.set(".wmlc", "application/vnd.wap.wmlc");
    MimeType.set(".wmlsc", "application/vnd.wap.wmlscriptc");
    MimeType.set(".wtb", "application/vnd.webturbo");
    MimeType.set(".wpd", "application/vnd.wordperfect");
    MimeType.set(".wqd", "application/vnd.wqd");
    MimeType.set(".stf", "application/vnd.wt.stf");
    MimeType.set(".xar", "application/vnd.xara");
    MimeType.set(".xfdl", "application/vnd.xfdl");
    MimeType.set(".hvd", "application/vnd.yamaha.hv-dic");
    MimeType.set(".hvs", "application/vnd.yamaha.hv-script");
    MimeType.set(".hvp", "application/vnd.yamaha.hv-voice");
    MimeType.set(".osf", "application/vnd.yamaha.openscoreformat");
    MimeType.set(".osfpvg", "application/vnd.yamaha.openscoreformat.osfpvg+xml");
    MimeType.set(".saf", "application/vnd.yamaha.smaf-audio");
    MimeType.set(".spf", "application/vnd.yamaha.smaf-phrase");
    MimeType.set(".cmp", "application/vnd.yellowriver-custom-menu");
    MimeType.set(".zir,.zirz", "application/vnd.zul");
    MimeType.set(".zaz", "application/vnd.zzazz.deck+xml");
    MimeType.set(".vxml", "application/voicexml+xml");
    MimeType.set(".hlp", "application/winhlp");
    MimeType.set(".wsdl", "application/wsdl+xml");
    MimeType.set(".wspolicy", "application/wspolicy+xml");
    MimeType.set(".abw", "application/x-abiword");
    MimeType.set(".ace", "application/x-ace-compressed");
    MimeType.set(".aab,.x32,.u32,.vox", "application/x-authorware-bin");
    MimeType.set(".aam", "application/x-authorware-map");
    MimeType.set(".aas", "application/x-authorware-seg");
    MimeType.set(".bcpio", "application/x-bcpio");
    MimeType.set(".torrent", "application/x-bittorrent");
    MimeType.set(".bz", "application/x-bzip");
    MimeType.set(".bz2,.boz", "application/x-bzip2");
    MimeType.set(".vcd", "application/x-cdlink");
    MimeType.set(".chat", "application/x-chat");
    MimeType.set(".pgn", "application/x-chess-pgn");
    MimeType.set(".cpio", "application/x-cpio");
    MimeType.set(".csh", "application/x-csh");
    MimeType.set(".deb,.udeb", "application/x-debian-package");
    MimeType.set(".dir,.dcr,.dxr,.cst,.cct,.cxt,.w3d,.fgd,.swa", "application/x-director");
    MimeType.set(".wad", "application/x-doom");
    MimeType.set(".ncx", "application/x-dtbncx+xml");
    MimeType.set(".dtb", "application/x-dtbook+xml");
    MimeType.set(".res", "application/x-dtbresource+xml");
    MimeType.set(".dvi", "application/x-dvi");
    MimeType.set(".bdf", "application/x-font-bdf");
    MimeType.set(".gsf", "application/x-font-ghostscript");
    MimeType.set(".psf", "application/x-font-linux-psf");
    MimeType.set(".otf", "application/x-font-otf");
    MimeType.set(".pcf", "application/x-font-pcf");
    MimeType.set(".snf", "application/x-font-snf");
    MimeType.set(".ttf,.ttc", "application/x-font-ttf");
    MimeType.set(".woff", "application/font-woff");
    MimeType.set(".pfa,.pfb,.pfm,.afm", "application/x-font-type1");
    MimeType.set(".spl", "application/x-futuresplash");
    MimeType.set(".gnumeric", "application/x-gnumeric");
    MimeType.set(".gtar", "application/x-gtar");
    MimeType.set(".hdf", "application/x-hdf");
    MimeType.set(".jnlp", "application/x-java-jnlp-file");
    MimeType.set(".latex", "application/x-latex");
    MimeType.set(".prc,.mobi", "application/x-mobipocket-ebook");
    MimeType.set(".application", "application/x-ms-application");
    MimeType.set(".wmd", "application/x-ms-wmd");
    MimeType.set(".wmz", "application/x-ms-wmz");
    MimeType.set(".xbap", "application/x-ms-xbap");
    MimeType.set(".mdb", "application/x-msaccess");
    MimeType.set(".obd", "application/x-msbinder");
    MimeType.set(".crd", "application/x-mscardfile");
    MimeType.set(".clp", "application/x-msclip");
    MimeType.set(".exe,.dll,.com,.bat,.msi", "application/x-msdownload");
    MimeType.set(".mvb,.m13,.m14", "application/x-msmediaview");
    MimeType.set(".wmf", "application/x-msmetafile");
    MimeType.set(".mny", "application/x-msmoney");
    MimeType.set(".pub", "application/x-mspublisher");
    MimeType.set(".scd", "application/x-msschedule");
    MimeType.set(".trm", "application/x-msterminal");
    MimeType.set(".wri", "application/x-mswrite");
    MimeType.set(".nc,.cdf", "application/x-netcdf");
    MimeType.set(".p12,.pfx", "application/x-pkcs12");
    MimeType.set(".p7b,.spc", "application/x-pkcs7-certificates");
    MimeType.set(".p7r", "application/x-pkcs7-certreqresp");
    MimeType.set(".rar", "application/x-rar-compressed");
    MimeType.set(".sh", "application/x-sh");
    MimeType.set(".shar", "application/x-shar");
    MimeType.set(".swf", "application/x-shockwave-flash");
    MimeType.set(".xap", "application/x-silverlight-app");
    MimeType.set(".sit", "application/x-stuffit");
    MimeType.set(".sitx", "application/x-stuffitx");
    MimeType.set(".sv4cpio", "application/x-sv4cpio");
    MimeType.set(".sv4crc", "application/x-sv4crc");
    MimeType.set(".tar", "application/x-tar");
    MimeType.set(".tcl", "application/x-tcl");
    MimeType.set(".tex", "application/x-tex");
    MimeType.set(".tfm", "application/x-tex-tfm");
    MimeType.set(".texinfo,.texi", "application/x-texinfo");
    MimeType.set(".ustar", "application/x-ustar");
    MimeType.set(".src", "application/x-wais-source");
    MimeType.set(".der,.crt", "application/x-x509-ca-cert");
    MimeType.set(".fig", "application/x-xfig");
    MimeType.set(".xpi", "application/x-xpinstall");
    MimeType.set(".xenc", "application/xenc+xml");
    MimeType.set(".xhtml,.xht", "application/xhtml+xml");
    MimeType.set(".xml,.xsl", "application/xml");
    MimeType.set(".dtd", "application/xml-dtd");
    MimeType.set(".xop", "application/xop+xml");
    MimeType.set(".xslt", "application/xslt+xml");
    MimeType.set(".xspf", "application/xspf+xml");
    MimeType.set(".mxml,.xhvml,.xvml,.xvm", "application/xv+xml");
    MimeType.set(".zip", "application/zip");
    MimeType.set(".adp", "audio/adpcm");
    MimeType.set(".au,.snd", "audio/basic");
    MimeType.set(".mid,.midi,.kar,.rmi", "audio/midi");
    MimeType.set(".mp4a", "audio/mp4");
    MimeType.set(".m4a,.m4p", "audio/mp4a-latm");
    MimeType.set(".mpga,.mp2,.mp2a,.mp3,.m2a,.m3a", "audio/mpeg");
    MimeType.set(".oga,.ogg,.spx", "audio/ogg");
    MimeType.set(".eol", "audio/vnd.digital-winds");
    MimeType.set(".dts", "audio/vnd.dts");
    MimeType.set(".dtshd", "audio/vnd.dts.hd");
    MimeType.set(".lvp", "audio/vnd.lucent.voice");
    MimeType.set(".pya", "audio/vnd.ms-playready.media.pya");
    MimeType.set(".ecelp4800", "audio/vnd.nuera.ecelp4800");
    MimeType.set(".ecelp7470", "audio/vnd.nuera.ecelp7470");
    MimeType.set(".ecelp9600", "audio/vnd.nuera.ecelp9600");
    MimeType.set(".aac", "audio/x-aac");
    MimeType.set(".aif,.aiff,.aifc", "audio/x-aiff");
    MimeType.set(".m3u", "audio/x-mpegurl");
    MimeType.set(".wax", "audio/x-ms-wax");
    MimeType.set(".wma", "audio/x-ms-wma");
    MimeType.set(".ram,.ra", "audio/x-pn-realaudio");
    MimeType.set(".rmp", "audio/x-pn-realaudio-plugin");
    MimeType.set(".wav", "audio/x-wav");
    MimeType.set(".cdx", "chemical/x-cdx");
    MimeType.set(".cif", "chemical/x-cif");
    MimeType.set(".cmdf", "chemical/x-cmdf");
    MimeType.set(".cml", "chemical/x-cml");
    MimeType.set(".csml", "chemical/x-csml");
    MimeType.set(".xyz", "chemical/x-xyz");
    MimeType.set(".bmp", "image/bmp");
    MimeType.set(".cgm", "image/cgm");
    MimeType.set(".g3", "image/g3fax");
    MimeType.set(".gif", "image/gif");
    MimeType.set(".ief", "image/ief");
    MimeType.set(".jp2", "image/jp2");
    MimeType.set(".jpeg,.jpg,.jpe", "image/jpeg");
    MimeType.set(".pict,.pic,.pct", "image/pict");
    MimeType.set(".png", "image/png");
    MimeType.set(".btif", "image/prs.btif");
    MimeType.set(".svg,.svgz", "image/svg+xml");
    MimeType.set(".tiff,.tif", "image/tiff");
    MimeType.set(".psd", "image/vnd.adobe.photoshop");
    MimeType.set(".djvu,.djv", "image/vnd.djvu");
    MimeType.set(".dwg", "image/vnd.dwg");
    MimeType.set(".dxf", "image/vnd.dxf");
    MimeType.set(".fbs", "image/vnd.fastbidsheet");
    MimeType.set(".fpx", "image/vnd.fpx");
    MimeType.set(".fst", "image/vnd.fst");
    MimeType.set(".mmr", "image/vnd.fujixerox.edmics-mmr");
    MimeType.set(".rlc", "image/vnd.fujixerox.edmics-rlc");
    MimeType.set(".mdi", "image/vnd.ms-modi");
    MimeType.set(".npx", "image/vnd.net-fpx");
    MimeType.set(".wbmp", "image/vnd.wap.wbmp");
    MimeType.set(".xif", "image/vnd.xiff");
    MimeType.set(".ras", "image/x-cmu-raster");
    MimeType.set(".cmx", "image/x-cmx");
    MimeType.set(".fh,.fhc,.fh4,.fh5,.fh7", "image/x-freehand");
    MimeType.set(".ico", "image/x-icon");
    MimeType.set(".pntg,.pnt,.mac", "image/x-macpaint");
    MimeType.set(".pcx", "image/x-pcx");
    //MimeType.set(".pic,.pct", "image/x-pict");
    MimeType.set(".pnm", "image/x-portable-anymap");
    MimeType.set(".pbm", "image/x-portable-bitmap");
    MimeType.set(".pgm", "image/x-portable-graymap");
    MimeType.set(".ppm", "image/x-portable-pixmap");
    MimeType.set(".qtif,.qti", "image/x-quicktime");
    MimeType.set(".rgb", "image/x-rgb");
    MimeType.set(".xbm", "image/x-xbitmap");
    MimeType.set(".xpm", "image/x-xpixmap");
    MimeType.set(".xwd", "image/x-xwindowdump");
    MimeType.set(".eml,.mime", "message/rfc822");
    MimeType.set(".igs,.iges", "model/iges");
    MimeType.set(".msh,.mesh,.silo", "model/mesh");
    MimeType.set(".dwf", "model/vnd.dwf");
    MimeType.set(".gdl", "model/vnd.gdl");
    MimeType.set(".gtw", "model/vnd.gtw");
    MimeType.set(".mts", "model/vnd.mts");
    MimeType.set(".vtu", "model/vnd.vtu");
    MimeType.set(".wrl,.vrml", "model/vrml");
    MimeType.set(".ics,.ifb", "text/calendar");
    MimeType.set(".css", "text/css");
    MimeType.set(".csv", "text/csv");
    MimeType.set(".html,.htm", "text/html");
    MimeType.set(".txt,.text,.conf,.def,.list,.log,.in", "text/plain");
    MimeType.set(".dsc", "text/prs.lines.tag");
    MimeType.set(".rtx", "text/richtext");
    MimeType.set(".sgml,.sgm", "text/sgml");
    MimeType.set(".tsv", "text/tab-separated-values");
    MimeType.set(".t,.tr,.roff,.man,.me,.ms", "text/troff");
    MimeType.set(".uri,.uris,.urls", "text/uri-list");
    MimeType.set(".curl", "text/vnd.curl");
    MimeType.set(".dcurl", "text/vnd.curl.dcurl");
    MimeType.set(".scurl", "text/vnd.curl.scurl");
    MimeType.set(".mcurl", "text/vnd.curl.mcurl");
    MimeType.set(".fly", "text/vnd.fly");
    MimeType.set(".flx", "text/vnd.fmi.flexstor");
    MimeType.set(".gv", "text/vnd.graphviz");
    MimeType.set(".3dml", "text/vnd.in3d.3dml");
    MimeType.set(".spot", "text/vnd.in3d.spot");
    MimeType.set(".jad", "text/vnd.sun.j2me.app-descriptor");
    MimeType.set(".wml", "text/vnd.wap.wml");
    MimeType.set(".wmls", "text/vnd.wap.wmlscript");
    MimeType.set(".s,.asm", "text/x-asm");
    MimeType.set(".c,.cc,.cxx,.cpp,.h,.hh,.dic", "text/x-c");
    MimeType.set(".f,.for,.f77,.f90", "text/x-fortran");
    MimeType.set(".p,.pas", "text/x-pascal");
    MimeType.set(".java", "text/x-java-source");
    MimeType.set(".etx", "text/x-setext");
    MimeType.set(".uu", "text/x-uuencode");
    MimeType.set(".vcs", "text/x-vcalendar");
    MimeType.set(".vcf", "text/x-vcard");
    MimeType.set(".3gp", "video/3gpp");
    MimeType.set(".3g2", "video/3gpp2");
    MimeType.set(".h261", "video/h261");
    MimeType.set(".h263", "video/h263");
    MimeType.set(".h264", "video/h264");
    MimeType.set(".jpgv", "video/jpeg");
    MimeType.set(".jpm,.jpgm", "video/jpm");
    MimeType.set(".mj2,.mjp2", "video/mj2");
    MimeType.set(".mp4,.mp4v,.mpg4,.m4v", "video/mp4");
    MimeType.set(".webm", "video/webm");
    MimeType.set(".mpeg,.mpg,.mpe,.m1v,.m2v", "video/mpeg");
    MimeType.set(".ogv", "video/ogg");
    MimeType.set(".qt,.mov", "video/quicktime");
    MimeType.set(".fvt", "video/vnd.fvt");
    MimeType.set(".mxu,.m4u", "video/vnd.mpegurl");
    MimeType.set(".pyv", "video/vnd.ms-playready.media.pyv");
    MimeType.set(".viv", "video/vnd.vivo");
    MimeType.set(".dv,.dif", "video/x-dv");
    MimeType.set(".f4v", "video/x-f4v");
    MimeType.set(".fli", "video/x-fli");
    MimeType.set(".flv", "video/x-flv");
    //MimeType.set(".m4v", "video/x-m4v");
    MimeType.set(".asf,.asx", "video/x-ms-asf");
    MimeType.set(".wm", "video/x-ms-wm");
    MimeType.set(".wmv", "video/x-ms-wmv");
    MimeType.set(".wmx", "video/x-ms-wmx");
    MimeType.set(".wvx", "video/x-ms-wvx");
    MimeType.set(".avi", "video/x-msvideo");
    MimeType.set(".movie", "video/x-sgi-movie");
    MimeType.set(".ice", "x-conference/x-cooltalk");

    // Compressed files
    // Based on notes at http://en.wikipedia.org/wiki/List_of_archive_formats
    MimeType.set(".gz", "application/x-gzip");
    MimeType.set(".tgz", "application/x-tar");
    MimeType.set(".tar", "application/x-tar");

    // Not really sure about these...
    MimeType.set(".epub", "application/epub+zip");
    MimeType.set(".mobi", "application/x-mobipocket-ebook");

    // Here's some common special cases without filename extensions
    MimeType.set("README,LICENSE,COPYING,TODO,ABOUT,AUTHORS,CONTRIBUTORS", "text/plain");
    MimeType.set("manifest,.manifest,.mf,.appcache", "text/cache-manifest");
    if (exports !== undefined) {
      exports.charset = MimeType.charset;
      exports.catalog = MimeType.catalog;
      exports.lookup = MimeType.lookup;
      exports.set = MimeType.set;
      exports.del = MimeType.del;
      exports.forEach = MimeType.forEach;
    }
    // Note: Chrome now defines window.MimeType, only define for legacy usage.
    if (self.MimeType === undefined) {
      self.MimeType = MimeType;
    }
    // Note: Per Hypercuded switch to camel case to avoid Chrome issues.
    if (self.mimeType === undefined) {
      self.mimeType = MimeType;
    }
    return self;
  })(this);

  /***/
},
/* 7 */
/***/function (module, exports) {

  function webpackEmptyContext(req) {
    throw new Error("Cannot find module '" + req + "'.");
  }
  webpackEmptyContext.keys = function () {
    return [];
  };
  webpackEmptyContext.resolve = webpackEmptyContext;
  module.exports = webpackEmptyContext;
  webpackEmptyContext.id = 7;

  /***/
},
/* 8 */
/***/function (module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function (process) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    // resolves . and .. elements in a path array with directory names there
    // must be no slashes, empty elements, or device names (c:\) in the array
    // (so also no leading and trailing slashes - it does not distinguish
    // relative and absolute paths)
    function normalizeArray(parts, allowAboveRoot) {
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }

      // if the path is allowed to go above the root, restore leading ..s
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }

      return parts;
    }

    // Split a filename into [root, dir, basename, ext], unix version
    // 'root' is just a slash, or nothing.
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var splitPath = function splitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    };

    // path.resolve([from ...], to)
    // posix version
    exports.resolve = function () {
      var resolvedPath = '',
          resolvedAbsolute = false;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : process.cwd();

        // Skip empty and invalid entries
        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }

        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }

      // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)

      // Normalize the path
      resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
        return !!p;
      }), !resolvedAbsolute).join('/');

      return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
    };

    // path.normalize(path)
    // posix version
    exports.normalize = function (path) {
      var isAbsolute = exports.isAbsolute(path),
          trailingSlash = substr(path, -1) === '/';

      // Normalize the path
      path = normalizeArray(filter(path.split('/'), function (p) {
        return !!p;
      }), !isAbsolute).join('/');

      if (!path && !isAbsolute) {
        path = '.';
      }
      if (path && trailingSlash) {
        path += '/';
      }

      return (isAbsolute ? '/' : '') + path;
    };

    // posix version
    exports.isAbsolute = function (path) {
      return path.charAt(0) === '/';
    };

    // posix version
    exports.join = function () {
      var paths = Array.prototype.slice.call(arguments, 0);
      return exports.normalize(filter(paths, function (p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }
        return p;
      }).join('/'));
    };

    // path.relative(from, to)
    // posix version
    exports.relative = function (from, to) {
      from = exports.resolve(from).substr(1);
      to = exports.resolve(to).substr(1);

      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '') break;
        }

        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '') break;
        }

        if (start > end) return [];
        return arr.slice(start, end - start + 1);
      }

      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));

      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }

      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }

      outputParts = outputParts.concat(toParts.slice(samePartsLength));

      return outputParts.join('/');
    };

    exports.sep = '/';
    exports.delimiter = ':';

    exports.dirname = function (path) {
      var result = splitPath(path),
          root = result[0],
          dir = result[1];

      if (!root && !dir) {
        // No dirname whatsoever
        return '.';
      }

      if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
      }

      return root + dir;
    };

    exports.basename = function (path, ext) {
      var f = splitPath(path)[2];
      // TODO: make this comparison case-insensitive on windows?
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };

    exports.extname = function (path) {
      return splitPath(path)[3];
    };

    function filter(xs, f) {
      if (xs.filter) return xs.filter(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
      }
      return res;
    }

    // String.prototype.substr - negative index don't work in IE8
    var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
      return str.substr(start, len);
    } : function (str, start, len) {
      if (start < 0) start = str.length + start;
      return str.substr(start, len);
    };

    /* WEBPACK VAR INJECTION */
  }).call(exports, __webpack_require__(9));

  /***/
},
/* 9 */
/***/function (module, exports) {

  // shim for using process in browser
  var process = module.exports = {};

  // cached from whatever global is present so that test runners that stub it
  // don't break things.  But we need to wrap it in a try catch in case it is
  // wrapped in strict mode code which doesn't define any globals.  It's inside a
  // function because try/catches deoptimize in certain engines.

  var cachedSetTimeout;
  var cachedClearTimeout;

  function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
  }
  (function () {
    try {
      if (typeof setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      //normal enviroments in sane situations
      return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e) {
        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      //normal enviroments in sane situations
      return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
        return cachedClearTimeout.call(null, marker);
      } catch (e) {
        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }

  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }

  process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };

  // v8 likes predictible objects
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function () {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = ''; // empty string to avoid regexp issues
  process.versions = {};

  function noop() {}

  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.prependListener = noop;
  process.prependOnceListener = noop;

  process.listeners = function (name) {
    return [];
  };

  process.binding = function (name) {
    throw new Error('process.binding is not supported');
  };

  process.cwd = function () {
    return '/';
  };
  process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function () {
    return 0;
  };

  /***/
},
/* 10 */
/***/function (module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function (Buffer) {
    var picker = function picker(type) {
      return function () {
        return new Promise(function (resolve, reject) {
          var fileLoader = function fileLoader(e) {
            var directory = {};
            var totalFiles = e.target.files.length;
            var loadedFiles = 0;
            [].map.call(e.target.files, function (file) {
              var reader = new FileReader();
              reader.onload = function (e) {
                var data = new Buffer(e.target.result);
                if (type === "directory") {
                  var path = file.webkitRelativePath;
                  directory[path.slice(path.indexOf("/") + 1)] = {
                    type: "text/plain",
                    data: data
                  };
                  if (++loadedFiles === totalFiles) resolve(directory);
                } else if (type === "file") {
                  var _path = file.webkitRelativePath;
                  resolve({ "type": mimetype.lookup(_path), "data": data });
                } else {
                  resolve(data);
                }
              };
              reader.readAsArrayBuffer(file);
            });
          };

          var fileInput = void 0;
          if (type === "directory") {
            fileInput = document.createElement("input");
            fileInput.addEventListener("change", fileLoader);
            fileInput.type = "file";
            fileInput.webkitdirectory = true;
            fileInput.mozdirectory = true;
            fileInput.msdirectory = true;
            fileInput.odirectory = true;
            fileInput.directory = true;
          } else {
            fileInput = document.createElement("input");
            fileInput.addEventListener("change", fileLoader);
            fileInput.type = "file";
          };

          var mouseEvent = document.createEvent("MouseEvents");
          mouseEvent.initEvent("click", true, false);
          fileInput.dispatchEvent(mouseEvent);
        });
      };
    };

    module.exports = {
      data: picker("data"),
      file: picker("file"),
      directory: picker("directory")
    };
    /* WEBPACK VAR INJECTION */
  }).call(exports, __webpack_require__(0).Buffer);

  /***/
},
/* 11 */
/***/function (module, exports, __webpack_require__) {

  "use strict";

  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function placeHoldersCount(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
  }

  function byteLength(b64) {
    // base64 is 4/3 + up to two characters of the original data
    return b64.length * 3 / 4 - placeHoldersCount(b64);
  }

  function toByteArray(b64) {
    var i, l, tmp, placeHolders, arr;
    var len = b64.length;
    placeHolders = placeHoldersCount(b64);

    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0; i < l; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 0xFF;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64(tmp));
    }
    return output.join('');
  }

  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 0x3F];
      output += lookup[tmp << 2 & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('');
  }

  /***/
},
/* 12 */
/***/function (module, exports) {

  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };

  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };

  /***/
},
/* 13 */
/***/function (module, exports) {

  var toString = {}.toString;

  module.exports = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  /***/
},
/* 14 */
/***/function (module, exports, __webpack_require__) {

  var request = __webpack_require__(15);

  module.exports = function (url, options) {
    return new Promise(function (resolve, reject) {
      request(url, options, function (err, data) {
        if (err) reject(err);else resolve(data);
      });
    });
  };

  /***/
},
/* 15 */
/***/function (module, exports, __webpack_require__) {

  var queryString = __webpack_require__(16);
  var setQuery = __webpack_require__(18);
  var assign = __webpack_require__(19);
  var ensureHeader = __webpack_require__(20);

  // this is replaced in the browser
  var request = __webpack_require__(21);

  var mimeTypeJson = 'application/json';
  var noop = function noop() {};

  module.exports = xhrRequest;
  function xhrRequest(url, opt, cb) {
    if (!url || typeof url !== 'string') {
      throw new TypeError('must specify a URL');
    }
    if (typeof opt === 'function') {
      cb = opt;
      opt = {};
    }
    if (cb && typeof cb !== 'function') {
      throw new TypeError('expected cb to be undefined or a function');
    }

    cb = cb || noop;
    opt = opt || {};

    var defaultResponse = opt.json ? 'json' : 'text';
    opt = assign({ responseType: defaultResponse }, opt);

    var headers = opt.headers || {};
    var method = (opt.method || 'GET').toUpperCase();
    var query = opt.query;
    if (query) {
      if (typeof query !== 'string') {
        query = queryString.stringify(query);
      }
      url = setQuery(url, query);
    }

    // allow json response
    if (opt.responseType === 'json') {
      ensureHeader(headers, 'Accept', mimeTypeJson);
    }

    // if body content is json
    if (opt.json && method !== 'GET' && method !== 'HEAD') {
      ensureHeader(headers, 'Content-Type', mimeTypeJson);
      opt.body = JSON.stringify(opt.body);
    }

    opt.method = method;
    opt.url = url;
    opt.headers = headers;
    delete opt.query;
    delete opt.json;

    return request(opt, cb);
  }

  /***/
},
/* 16 */
/***/function (module, exports, __webpack_require__) {

  "use strict";

  var strictUriEncode = __webpack_require__(17);

  exports.extract = function (str) {
    return str.split('?')[1] || '';
  };

  exports.parse = function (str) {
    if (typeof str !== 'string') {
      return {};
    }

    str = str.trim().replace(/^(\?|#|&)/, '');

    if (!str) {
      return {};
    }

    return str.split('&').reduce(function (ret, param) {
      var parts = param.replace(/\+/g, ' ').split('=');
      // Firefox (pre 40) decodes `%3D` to `=`
      // https://github.com/sindresorhus/query-string/pull/37
      var key = parts.shift();
      var val = parts.length > 0 ? parts.join('=') : undefined;

      key = decodeURIComponent(key);

      // missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
      val = val === undefined ? null : decodeURIComponent(val);

      if (!ret.hasOwnProperty(key)) {
        ret[key] = val;
      } else if (Array.isArray(ret[key])) {
        ret[key].push(val);
      } else {
        ret[key] = [ret[key], val];
      }

      return ret;
    }, {});
  };

  exports.stringify = function (obj) {
    return obj ? Object.keys(obj).sort().map(function (key) {
      var val = obj[key];

      if (Array.isArray(val)) {
        return val.sort().map(function (val2) {
          return strictUriEncode(key) + '=' + strictUriEncode(val2);
        }).join('&');
      }

      return strictUriEncode(key) + '=' + strictUriEncode(val);
    }).filter(function (x) {
      return x.length > 0;
    }).join('&') : '';
  };

  /***/
},
/* 17 */
/***/function (module, exports, __webpack_require__) {

  "use strict";

  module.exports = function (str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase();
    });
  };

  /***/
},
/* 18 */
/***/function (module, exports) {

  module.exports = urlSetQuery;
  function urlSetQuery(url, query) {
    if (query) {
      // remove optional leading symbols
      query = query.trim().replace(/^(\?|#|&)/, '');

      // don't append empty query
      query = query ? '?' + query : query;

      var parts = url.split(/[\?\#]/);
      var start = parts[0];
      if (query && /\:\/\/[^\/]*$/.test(start)) {
        // e.g. http://foo.com -> http://foo.com/
        start = start + '/';
      }
      var match = url.match(/(\#.*)$/);
      url = start + query;
      if (match) {
        // add hash back in
        url = url + match[0];
      }
    }
    return url;
  }

  /***/
},
/* 19 */
/***/function (module, exports, __webpack_require__) {

  "use strict";

  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function ToObject(val) {
    if (val == null) {
      throw new TypeError('Object.assign cannot be called with null or undefined');
    }

    return Object(val);
  }

  function ownEnumerableKeys(obj) {
    var keys = Object.getOwnPropertyNames(obj);

    if (Object.getOwnPropertySymbols) {
      keys = keys.concat(Object.getOwnPropertySymbols(obj));
    }

    return keys.filter(function (key) {
      return propIsEnumerable.call(obj, key);
    });
  }

  module.exports = Object.assign || function (target, source) {
    var from;
    var keys;
    var to = ToObject(target);

    for (var s = 1; s < arguments.length; s++) {
      from = arguments[s];
      keys = ownEnumerableKeys(Object(from));

      for (var i = 0; i < keys.length; i++) {
        to[keys[i]] = from[keys[i]];
      }
    }

    return to;
  };

  /***/
},
/* 20 */
/***/function (module, exports) {

  module.exports = ensureHeader;
  function ensureHeader(headers, key, value) {
    var lower = key.toLowerCase();
    if (!headers[key] && !headers[lower]) {
      headers[key] = value;
    }
  }

  /***/
},
/* 21 */
/***/function (module, exports, __webpack_require__) {

  var xhr = __webpack_require__(22);
  var normalize = __webpack_require__(28);

  module.exports = xhrRequest;
  function xhrRequest(opt, cb) {
    delete opt.uri;

    // for better JSON.parse error handling than xhr module
    var useJson = false;
    if (opt.responseType === 'json') {
      opt.responseType = 'text';
      useJson = true;
    }

    return xhr(opt, function xhrRequestResult(err, resp, body) {
      if (useJson && !err) {
        try {
          var text = resp.rawRequest.responseText;
          body = JSON.parse(text);
        } catch (e) {
          err = e;
        }
      }

      resp = normalize(opt, resp);
      if (err) cb(err, null, resp);else cb(err, body, resp);
    });
  }

  /***/
},
/* 22 */
/***/function (module, exports, __webpack_require__) {

  "use strict";

  var window = __webpack_require__(23);
  var isFunction = __webpack_require__(2);
  var parseHeaders = __webpack_require__(24);
  var xtend = __webpack_require__(27);

  module.exports = createXHR;
  createXHR.XMLHttpRequest = window.XMLHttpRequest || noop;
  createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window.XDomainRequest;

  forEachArray(["get", "put", "post", "patch", "head", "delete"], function (method) {
    createXHR[method === "delete" ? "del" : method] = function (uri, options, callback) {
      options = initParams(uri, options, callback);
      options.method = method.toUpperCase();
      return _createXHR(options);
    };
  });

  function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
      iterator(array[i]);
    }
  }

  function isEmpty(obj) {
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) return false;
    }
    return true;
  }

  function initParams(uri, options, callback) {
    var params = uri;

    if (isFunction(options)) {
      callback = options;
      if (typeof uri === "string") {
        params = { uri: uri };
      }
    } else {
      params = xtend(options, { uri: uri });
    }

    params.callback = callback;
    return params;
  }

  function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback);
    return _createXHR(options);
  }

  function _createXHR(options) {
    if (typeof options.callback === "undefined") {
      throw new Error("callback argument missing");
    }

    var called = false;
    var callback = function cbOnce(err, response, body) {
      if (!called) {
        called = true;
        options.callback(err, response, body);
      }
    };

    function readystatechange() {
      if (xhr.readyState === 4) {
        setTimeout(loadFunc, 0);
      }
    }

    function getBody() {
      // Chrome with requestType=blob throws errors arround when even testing access to responseText
      var body = undefined;

      if (xhr.response) {
        body = xhr.response;
      } else {
        body = xhr.responseText || getXml(xhr);
      }

      if (isJson) {
        try {
          body = JSON.parse(body);
        } catch (e) {}
      }

      return body;
    }

    function errorFunc(evt) {
      clearTimeout(timeoutTimer);
      if (!(evt instanceof Error)) {
        evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
      }
      evt.statusCode = 0;
      return callback(evt, failureResponse);
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
      if (aborted) return;
      var status;
      clearTimeout(timeoutTimer);
      if (options.useXDR && xhr.status === undefined) {
        //IE8 CORS GET successful response doesn't have a status field, but body is fine
        status = 200;
      } else {
        status = xhr.status === 1223 ? 204 : xhr.status;
      }
      var response = failureResponse;
      var err = null;

      if (status !== 0) {
        response = {
          body: getBody(),
          statusCode: status,
          method: method,
          headers: {},
          url: uri,
          rawRequest: xhr
        };
        if (xhr.getAllResponseHeaders) {
          //remember xhr can in fact be XDR for CORS in IE
          response.headers = parseHeaders(xhr.getAllResponseHeaders());
        }
      } else {
        err = new Error("Internal XMLHttpRequest Error");
      }
      return callback(err, response, response.body);
    }

    var xhr = options.xhr || null;

    if (!xhr) {
      if (options.cors || options.useXDR) {
        xhr = new createXHR.XDomainRequest();
      } else {
        xhr = new createXHR.XMLHttpRequest();
      }
    }

    var key;
    var aborted;
    var uri = xhr.url = options.uri || options.url;
    var method = xhr.method = options.method || "GET";
    var body = options.body || options.data;
    var headers = xhr.headers = options.headers || {};
    var sync = !!options.sync;
    var isJson = false;
    var timeoutTimer;
    var failureResponse = {
      body: undefined,
      headers: {},
      statusCode: 0,
      method: method,
      url: uri,
      rawRequest: xhr
    };

    if ("json" in options && options.json !== false) {
      isJson = true;
      headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json"); //Don't override existing accept header declared by user
      if (method !== "GET" && method !== "HEAD") {
        headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json"); //Don't override existing accept header declared by user
        body = JSON.stringify(options.json === true ? body : options.json);
      }
    }

    xhr.onreadystatechange = readystatechange;
    xhr.onload = loadFunc;
    xhr.onerror = errorFunc;
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
      // IE must die
    };
    xhr.onabort = function () {
      aborted = true;
    };
    xhr.ontimeout = errorFunc;
    xhr.open(method, uri, !sync, options.username, options.password);
    //has to be after open
    if (!sync) {
      xhr.withCredentials = !!options.withCredentials;
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0) {
      timeoutTimer = setTimeout(function () {
        if (aborted) return;
        aborted = true; //IE9 may still call readystatechange
        xhr.abort("timeout");
        var e = new Error("XMLHttpRequest timeout");
        e.code = "ETIMEDOUT";
        errorFunc(e);
      }, options.timeout);
    }

    if (xhr.setRequestHeader) {
      for (key in headers) {
        if (headers.hasOwnProperty(key)) {
          xhr.setRequestHeader(key, headers[key]);
        }
      }
    } else if (options.headers && !isEmpty(options.headers)) {
      throw new Error("Headers cannot be set on an XDomainRequest object");
    }

    if ("responseType" in options) {
      xhr.responseType = options.responseType;
    }

    if ("beforeSend" in options && typeof options.beforeSend === "function") {
      options.beforeSend(xhr);
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null);

    return xhr;
  }

  function getXml(xhr) {
    if (xhr.responseType === "document") {
      return xhr.responseXML;
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
      return xhr.responseXML;
    }

    return null;
  }

  function noop() {}

  /***/
},
/* 23 */
/***/function (module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function (global) {
    var win;

    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof global !== "undefined") {
      win = global;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }

    module.exports = win;

    /* WEBPACK VAR INJECTION */
  }).call(exports, __webpack_require__(1));

  /***/
},
/* 24 */
/***/function (module, exports, __webpack_require__) {

  var trim = __webpack_require__(25),
      forEach = __webpack_require__(26),
      isArray = function isArray(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };

  module.exports = function (headers) {
    if (!headers) return {};

    var result = {};

    forEach(trim(headers).split('\n'), function (row) {
      var index = row.indexOf(':'),
          key = trim(row.slice(0, index)).toLowerCase(),
          value = trim(row.slice(index + 1));

      if (typeof result[key] === 'undefined') {
        result[key] = value;
      } else if (isArray(result[key])) {
        result[key].push(value);
      } else {
        result[key] = [result[key], value];
      }
    });

    return result;
  };

  /***/
},
/* 25 */
/***/function (module, exports) {

  exports = module.exports = trim;

  function trim(str) {
    return str.replace(/^\s*|\s*$/g, '');
  }

  exports.left = function (str) {
    return str.replace(/^\s*/, '');
  };

  exports.right = function (str) {
    return str.replace(/\s*$/, '');
  };

  /***/
},
/* 26 */
/***/function (module, exports, __webpack_require__) {

  var isFunction = __webpack_require__(2);

  module.exports = forEach;

  var toString = Object.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
      throw new TypeError('iterator must be a function');
    }

    if (arguments.length < 3) {
      context = this;
    }

    if (toString.call(list) === '[object Array]') forEachArray(list, iterator, context);else if (typeof list === 'string') forEachString(list, iterator, context);else forEachObject(list, iterator, context);
  }

  function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (hasOwnProperty.call(array, i)) {
        iterator.call(context, array[i], i, array);
      }
    }
  }

  function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
      // no such thing as a sparse string.
      iterator.call(context, string.charAt(i), i, string);
    }
  }

  function forEachObject(object, iterator, context) {
    for (var k in object) {
      if (hasOwnProperty.call(object, k)) {
        iterator.call(context, object[k], k, object);
      }
    }
  }

  /***/
},
/* 27 */
/***/function (module, exports) {

  module.exports = extend;

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function extend() {
    var target = {};

    for (var i = 0; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  }

  /***/
},
/* 28 */
/***/function (module, exports) {

  module.exports = getResponse;
  function getResponse(opt, resp) {
    if (!resp) return null;
    return {
      statusCode: resp.statusCode,
      headers: resp.headers,
      method: opt.method,
      url: opt.url,
      // the XHR object in browser, http response in Node
      rawRequest: resp.rawRequest ? resp.rawRequest : resp
    };
  }

  /***/
},
/* 29 */
/***/function (module, exports) {

  module.exports = { "windows-amd64": { "archive": "swarm-windows-amd64-1.6.7.exe", "binaryMD5": "c2d827dc4553d9b91a7d6c1d5a6140fd", "archiveMD5": "059196d21548060a18a12e17cc0ee59a" }, "linux-amd64": { "archive": "swarm-linux-amd64-1.6.7", "binaryMD5": "85002d79b8ebc2d2f2f10fb198636a81", "archiveMD5": "3e8874299ab8c0e3043d70ebb6673879" }, "linux-386": { "archive": "swarm-linux-386-1.6.7", "binaryMD5": "35bc2ab976f60f96a2cede117e0df19d", "archiveMD5": "7868a86c9cbdf8ac7ac2e5682b4ce40f" }, "darwin-amd64": { "archive": "swarm-darwin-amd64-1.6.7", "binaryMD5": "c499b186645229260dd6ab685dd58f07", "archiveMD5": "0794d111e5018eac3b657bcb29851121" }, "linux-arm5": { "archive": "swarm-linux-arm5-1.6.7", "binaryMD5": "516fcd85246c905529442cd9b689c12f", "archiveMD5": "47312708d417cb196b07ba0af1d3abb4" }, "linux-arm6": { "archive": "swarm-linux-arm6-1.6.7", "binaryMD5": "82ff7bdbe388b4a190f4101c5150d3b4", "archiveMD5": "350276de7bb175a15c314cfc4cb7f8fd" }, "linux-mips": { "archive": "swarm-linux-mips-1.6.7", "binaryMD5": "e1e95280441c0ca35633927792ef5317", "archiveMD5": "8fb4b64e94cd73aa718db787b9d4c53e" }, "linux-arm7": { "archive": "swarm-linux-arm7-1.6.7", "binaryMD5": "bfc0b4d1c86d8a975af052fc7854bdd3", "archiveMD5": "4378641d8e1e1fbb947f941c8fca8613" }, "linux-arm64": { "archive": "swarm-linux-arm64-1.6.7", "binaryMD5": "bbac21a6c6fa8208f67ca4123d3f948a", "archiveMD5": "4e503160327c5fbcca0414f17c54e5ee" }, "linux-mipsle": { "archive": "swarm-linux-mipsle-1.6.7", "binaryMD5": "a82f191b2f9d2c470d0273219c820657", "archiveMD5": "3016bdb6d237ae654c0cdf36fe85dc7c" }, "windows-386": { "archive": "swarm-windows-386-1.6.7.exe", "binaryMD5": "ce0b34640642e58068ae5a359faef102", "archiveMD5": "640aede4da08a3a9d8a6ac0434ba7c0f" }, "linux-mips64": { "archive": "swarm-linux-mips64-1.6.7", "binaryMD5": "9da967664f384817adb5083fd1ffe8f1", "archiveMD5": "357a33be470f8f89ba2619957a08deff" }, "linux-mips64le": { "archive": "swarm-linux-mips64le-1.6.7", "binaryMD5": "ec1abcf7b216e87645ec83954d8344cd", "archiveMD5": "a81fd0158190d99813c738ffa4f87627" }

    /***/ };
}]
/******/);